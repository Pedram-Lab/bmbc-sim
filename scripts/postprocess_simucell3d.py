# %%
from math import sqrt

import pyvista as pv
import matplotlib.pyplot as plt
from ngsolve.webgui import Draw
import ngsolve as ngs
from netgen import occ

from ecsim.geometry import TissueGeometry
from ecsim import plot_style

# %%
# Load the mesh (which is a vtk file generated by SimuCell3D)
geometry = TissueGeometry.from_file("result_3590.vtk")

# %%
# Scale it so that the bounding box is roughly [-5, 5]^3
geometry = geometry.scale(40000)
min_coords, max_coords = geometry.bounding_box()
print(f"Bounding box: {min_coords}, {max_coords}")

# %%
# Post-process the mesh to create ECS and make the surfaces look nicer
ECS_RATIO = 0.3
geometry = geometry.shrink_cells(1 - ECS_RATIO, jitter=0.1)
geometry = geometry.smooth(100)
geometry = geometry.decimate(0.7)

# %%
# Manually remove some cells that didn't successfully mesh
# TODO: properly clean the cells
all_cells = geometry.cells
faulty_cells = {47, 58, 139, 149, 162, 214, 295, 296, 298, 309, 441, 462, 556, 584, 680, 897}
working_cells = [c for i, c in enumerate(all_cells) if not i in faulty_cells]
geometry = TissueGeometry(working_cells)

# %%
# To see where the faulty cells are, uncomment the following lines
# faulty_cells = [c for i, c in enumerate(all_cells) if i in faulty_cells]
# fault_geometry = TissueGeometry(faulty_cells)
# plotter = pv.Plotter()
# plotter.add_mesh(geometry.as_single_mesh(), opacity=0.05)
# plotter.add_mesh(fault_geometry.as_single_mesh(), color='red')
# box = pv.Box((1.2, 3.2, -0.8, 1.2, 0, 2))
# plotter.add_mesh(box, color='gray')
# plotter.show_grid()
# plotter.show()

# %%
# Extract cells from a small center portion
box_bounds = (1.2, 3.2, -0.8, 1.2, 0, 2)
geometry = geometry.keep_cells_within(
    min_coords=box_bounds[::2],
    max_coords=box_bounds[1::2],
    inside_threshold=0.1
)

# %%
# Visualize the mesh together with the bounding box
combined_mesh = geometry.as_single_mesh()
plotter = pv.Plotter()
box = pv.Box(box_bounds)
plotter.add_mesh(combined_mesh, scalars='face_cell_id', show_edges=True, cmap='tab20b')
plotter.add_mesh(box, color='gray', opacity=0.5)
plotter.show()

# %% Create an ngsolve mesh and visualize it
tissue_mesh = geometry.to_ngs_mesh(
    mesh_size=1.0,
    min_coords=box_bounds[::2],
    max_coords=box_bounds[1::2],
    projection_tol=0.01,
)
print(f"Created mesh with {tissue_mesh.nv} vertices and {tissue_mesh.ne} elements")
Draw(tissue_mesh)

# %%
# Compute the tortuosity by solving a diffusion problem
def compute_diffusion_time(
        mesh: ngs.Mesh,
        filename: str = None,
) -> tuple[float, ngs.GridFunction]:
    """
    Function to compute the time needed for a substance to diffuse through a
    (geometrically porous) medium. The time is given by the time it takes for
    the substance to reach a concentration of 50% of the concentration density
    at the left boundary at the right boundary.

    :param mesh: Netgen mesh
    :param filename: Name of the file to save the time-evolution to. If None,
        the time-evolution is not saved.
    :return: Time needed for diffusion
    """
    # Define FE space
    fes = ngs.H1(mesh, order=1, dirichlet="left", definedon="ecs")
    c = ngs.GridFunction(fes)
    tau = 0.001

    # Set up output if desired
    vtk_output = None
    if filename is not None:
        vtk_output = ngs.VTKOutput(mesh, coefs=[c], names=["concentration"], filename=filename)

    # Define diffusion problem
    trial, test = fes.TnT()
    a = ngs.BilinearForm(fes)
    a += ngs.grad(trial) * ngs.grad(test) * ngs.dx
    m = ngs.BilinearForm(fes)
    m += trial * test * ngs.dx

    # Time stepping
    c.Set(0)
    c.Set(1, definedon=mesh.Boundaries("left"))
    right_area = ngs.Integrate(1, mesh, definedon=mesh.Boundaries("right"))
    right_substance = 0
    n = 0

    ngs.SetNumThreads(8)
    with ngs.TaskManager():
        a.Assemble()
        m.Assemble()
        m.mat.AsVector().data += tau * a.mat.AsVector()
        smoother = m.mat.CreateSmoother(fes.FreeDofs(), GS=True)
        mstar_inv = ngs.CGSolver(m.mat, smoother)

        while right_substance / right_area < 0.5:
            res = -tau * (a.mat * c.vec)
            c.vec.data += mstar_inv * res
            right_substance = ngs.Integrate(
                c, mesh, definedon=mesh.Boundaries("right"))
            n += 1
            if n % 20 == 0 and vtk_output is not None:
                vtk_output.Do(time=n * tau)

    return n * tau

# %%
# Compute diffusion time in free space
box = occ.Box(box_bounds[::2], box_bounds[1::2])
box.mat("ecs")
for i, name in enumerate(["left", "right", "top", "bottom", "front", "back"]):
    box.faces[i].bc(name)
box_mesh = ngs.Mesh(occ.OCCGeometry(box).GenerateMesh(maxh=0.05))
print(f"Created box mesh with {box_mesh.nv} vertices and {box_mesh.ne} elements")
t_unhindered = compute_diffusion_time(box_mesh)
print(f"Time needed for diffusion: {t_unhindered:.2f} ms")

# %%
# Compute diffusion time in tissue
t_tissue = compute_diffusion_time(tissue_mesh)
print(f"Time needed for diffusion in tissue: {t_tissue:.2f} ms")
print(f"Tortuosity: {sqrt(t_tissue / t_unhindered):.2f}")

# %%
# Plot tortuosity over different ECS ratios
results = [
    (0.05, 1.41),
    (0.10, 1.29),
    (0.15, 1.24),
    (0.20, 1.22),
    (0.25, 1.19),
    (0.30, 1.17),
    (0.35, 1.15),
    (0.40, 1.13),
    (0.45, 1.13),
    (0.50, 1.12),
]

width, height = plot_style("pedramlab")
fig, ax = plt.subplots(figsize=(width, height))
ax.plot([r[0] for r in results], [r[1] for r in results], color="black", marker="o")
ax.set_xlabel("ECS ratio")
ax.set_ylabel("Tortuosity")
plt.tight_layout()
plt.show()

# %%
